# Effective JavaScript
编写高质量JavaScript代码的68个有效方法

## 让自己习惯JavaScript

### 1、了解你使用的JavaScript版本
>   1. 确定代码中使用的具体JavaScript版本，并统一编码；
>   2. 确保代码中使用的所有JavaScript特性对于应用程序将要运行的所有环境都是支持的；
>   3. 总是使用严格模式，并在支持严格模式检查的环境中测试代码；
>   4. 当心合并严格代码和非严格代码。

### 2、理解JavaScript的浮点数
>   1. JavaScript中的数字都是双精度浮点数，符合IEEE 754标准制定的64位编码数字——即“doubles”，尽管64位的精度已经相当高，但是浮点数所能表示的也只是一组有限的数字，而不能表示所有的实数集。浮点运算只能产生相似的结果，四舍五入到最接近的可表示的实数；
>   2. JavaScript中的整数仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型；
>   3. JavaScript中位运算比较特殊，首先将浮点数隐式的转化为32位整数（32位大端，big-endian），然后使用整数位模式进行运算，最后将结果转换为标准的JavaScript浮点数；
>   4. 当心浮点运算中的精度陷阱。

### 3、当心隐式的强制转换
>   1. 类型错误可能被隐式的强制转换所隐藏；
>   2. 重载的运算符+是进行加法运算还是字符串链接操作取决于其参数类型（左结合律）；
>   3. 对象通过valueOf方法强制转化为数字，通过toString方法强制转化为字符串；
>   4. 具有valueOf方法的对象应该实现toString方法，返回一个valueOf方法产生的数字的字符串表示；
>   5. 测试一个值是否为未定义的值，应该使用typeof操作符或者与undefined进行比较而不能进行真值运算。

### 4、原始类型优于封装对象
>   1. 除了对象之外，JavaScript有5个原始值类型：布尔值、数字、字符串、null和undefined（ECMAScript标准规定null是一个特殊的类型，但 `typeof` 操作符得到的结果为“object”；
>   2. 当做相等比较时，原始类型的封装对象与其原始值行为不一样；
>   3. 获取和设置原始类型值的属性会隐式的创建封装对象。

### 5、避免对混合类型使用==运算符
#### `==`运算符的强制转换规则
| 操作数1类型 | 操作数2类型 | 强制转换 |
|------------|------------|---------|
| null | undefined| 不转换，总是返回true |
| null或undefined | 其他任何非null或undefined的类型 | 不转换，总是返回false |
| string，number或boolean | Date对象 | 将原始类型转换为数字；将Date对象转换为原始类型（优先尝试toString方法，再尝试valueOf方法） |
| string，number或boolean | 非Date对象 | 将原始类型转换为数字；将非Date对象转换为原始类型（优先尝试valueOf方法，再尝试toString方法） |
| string，number或boolean | string，number或boolean | 将原始类型转换为数字 |

>   1. 当参数类型不同时，`==`运算符应用了一套难以理解的隐式强制转换规则；
>   2. 使用`===`运算符，不涉及任何的隐式强制转换就能明白比较运算；
>   3. 当比较不同类型的值时，使用显式的强制转换使程序的行为更清晰。

### 6、了解分号插入插入（automatic semicolon insertion）的局限
#### 分号插入规则
1. 分号仅在`}`标记之前、一个或多个换行之后和程序输入的结尾被插入，只能在一行、一个代码块和一段程序结束的地方省略分号；
2. 分号仅在随后的标记不能解析时插入，分号插入是一种错误矫正机制；
    `(`、`[`、`+`、`-`和`/`五个字符都能作为一个表达式运算符或者一条语句的前缀，这依赖于具体上下文。需要密切关注下一条语句的开始，从而发现你是否能合法的省略分号。
    JavaScript语法限制产生式（restricted production）不允许在两个字符字符之间出现换行，JavaScript会强制插入分号。
    1. `return`关键字；
    2. `throw`语句；
    3. 带有显式标签的`break`或`continue`语句；
    4. 后置自增或自减运算符（自增运算符即可以前置也可以后置，但是后置运算符不能出现在换行之后）。
3. 分号不会作为分隔符在`for`循环空语句的头部被自动插入，空循环体的`while`循环同样也需要显式的分号。

>   1. 仅在`}`标记之前、一行的结束和程序的结束处推导分号；
>   2. 仅在紧接着的标记不能被解析的时候推导分号；
>   3. 在以`(`、`[`、`+`、`-`或`/`字符开头的语句前决不能省略分号；
>   4. 当脚本链接的时候，在脚本之间显示的插入分号；
>   5. 在`return`、`throw`、`break`、`continue`、`++`或`--`的参数之前决不能换行；
>   6. 分号不能作为`for`循环的头部或空语句的分隔符而被推导出来。

### 7、视字符串为16位的代码单元序列
>	1. JavaScript字符串由16位的代码单元组成，而不是由Unicode代码点组成；
>	2. JavaScript使用两个代码单元表示2^16及其以上的Unicode代码点，这两个代码单元被称为代理对；
>	3. 字符串属性和方法（如`length`，`charAt`和`charCodeAt`）和正则表达式（如单字符模式`.`）都是基于代码单元层级，而不是代码点层级。基本多文种平面（Basic Multilingual Plane，BMP）中的字符用一个代码单元表示，辅助平面（supplementary plane）中的字符用两个代码单元表示；
>	4. 使用第三方库编写可识别代码点的字符串操作；
>	5. 每当你使用一个含有字符串操作的库时，你都需要查阅该库文档，确认其处理代码点整个范围的方式。

## 变量作用域
### 8、尽量少用全局对象
>	1. 避免声明全局变量；
>	2. 尽量声明局部变量，变量的作用域控制的越小越好；
>	3. 避免对全局对象添加属性；
>	4. 使用全局对象来做平台特性检测。

### 9、始终声明局部变量
如果存在比全局变量更麻烦的事，那就是意外的全局变量；故意的创建全局变量是不好的风格，而意外的创建全局变量僵尸彻头彻尾的灾难。

>	1. 始终使用var声明新的局部变量；
>	2. 使用lint工具帮忙检查未声明的变量。

### 10、避免使用with
在with代码块的内部，变量查找从搜索给定的对象名的属性开始。如果在这个对象中没有找到该属性，则继续在外部作用域中搜索。在一个正常的作用域中，与局部作用域中的局部变量一一对应的作用域绑定存储在与之对应的环境层级中；但对于with作用域，绑定集合依赖于执行时间点时的对象。
人力不可预测的特性对于优化编译器同样不可预测。通常情况下，JavaScript作用域可被表示为高效的内部数据结构，变量查找会非常快速。但是由于with代码块需要搜索对象的原型链来查找with代码块中的所有变量，其运行速度远低于一般的代码块。

>	1. 避免使用with语句；
>	2. 使用简短的变量名代替重复访问的对象；
>	3. 显式的将对象属性赋值给局部变量，而不是使用with语句隐式的引用它们。
>	```
>	// 不推荐
>   var max = Math.max;
>   with(Math) {
>	    max(x, y);
>	}
>	// 推荐
>   var max = Math.max;
>   max(x, y);
>	```

### 11、熟练使用闭包
#### 闭包的三个基础：
1. JavaScript允许你引用在当前函数以外定义的变量；
2. JavaScript的函数是第一类（first-class）对象，你可以返回一个内部函数，并在稍后调用它。即使外部函数调用已经结束，返回的内部函数仍然可以引用在外部函数中所定义的变量；
    > JavaScript的函数值包含了比调用它们时执行所需要的代码还要多的信息，在函数值内部存储该函数可能会引用的定义在其封闭作用域的变量。在其所涵盖的作用域内跟踪变量的函数被称为闭包。
3. 闭包可以更新外部变量的值，闭包存储的是其外部变量的引用而不是值；

>   1. 函数可以引用定义在其外部作用域的变量；
>   2. 闭包比创建它们的函数有更长的生命周期；
>   3. 闭包在内部存储其引用的外部变量，并能读写这些变量。

### 12、理解变量声明提升
JavaScript支持词法作用域（lexical scoping），但不支持块级作用域。可以把JavaScript中变量声明看成声明和赋值两部分。JavaScript会隐式提升（hoists）声明部分到函数的顶部，而将赋值留在原地。

异常处理是JavaScript中没有块级作用域的反例，try…catch语句将捕获的异常绑定到一个变量，该变量的作用域只有catch语句块。

>   1. 在代码块中变量声明会被隐式的提升到函数的顶部；
>   2. 重复声明的变量被视为同一个变量；
>   3. 考虑手动提升局部变量的声明，从而避免混淆。

### 13、使用立即调用的函数表达式创建局部作用域
>   1. 理解绑定与赋值的区别；
>   2. 闭包通过引用而不是值来捕获他们的外部变量；
>   3. 使用立即调用的函数表达式（IIFE，发音为“iffy”）来创建局部作用域；
>   4. 当心在立即调用的函数表达式中包裹代码块可能改变其行为的情形（比如代码块中不能包含跳出块的break和continue语句）。

### 14、当心命名函数表达式笨拙的作用域
匿名和命名函数表达式（named function expression）的官方区别在于后者会绑定到其函数名相同的变量上，该变量将作为该函数内的一个局部变量。
遗憾的是，命名函数表达式的作用域和兼容性问题严重，主要是两方面的原因，ECMAScript规范的错误和主流JavaScript引擎中的Bug。

规范的错误在ES3中就存在，规范要求将命名函数表达式的作用域表示为一个对象，该作用域对象只包含一个属性，该属性将函数名和函数自身绑定起来。该作用域对象也继承了Object.prototype的属性。这意味着仅仅是给函数表达式命名也会将Object.prototype中的所有属性引入到作用域中。幸运的是ES5修正了这个错误，在Chrome50、Safari9.1和Firefox 45中未复现这个错误。
在系统中避免对象污染函数表达式作用域的最好方式是避免任何时候在Object.prototype中添加属性，以及避免使用任何与标准Object.prototype属性同名的局部变量。

一些JavaScript引擎中存在的另一个缺陷是对命名函数表达式的声明提升到函数定义所在的作用域，个别JavaScript引擎甚至把函数表达式变量和命名匿名表达式这两个函数当做不同的对象，导致重复的内存分配。在Chrome50、Safari9.1和Firefox 45中未复现这个错误。

> 1. 在Error对象和调试器对象中使用命名函数表达式改进栈追踪；
> 2. 在ES3和有问题的JavaScript环境中谨记命名函数表达式的作用域会被Object.prototype污染；
> 3. 谨记在错误百出的JavaScript环境中提升命名函数表达式声明的错误，并导致命名函数表达式的重复污染；
> 4. 考虑避免使用命名函数表达式或在发布前删除函数名；
> 5. 如果你将代码发布到正确实现的ES5环境中，那么你没有什么好担心的。

### 15、当心局部块函数声明笨拙的作用域
JavaScript没有块级作用域，所以块级代码中的内部函数的作用域应该是整个函数。但并不是所有的JavaScript环境都这样，有些环境在运行时根据包含函数的块是否被执行来有条件的绑定内部函数。

> 1. 始终将函数声明置于程序或被包含的函数的最外层以避免不可移植的行为；
> 2. 使用var声明和有条件的赋值语句代替有条件的函数声明。

### 16、避免使用eval创建局部变量
ES5严格模式将eval函数运行在一个嵌套的作用域中以防止作用域污染，保证eval函数不影响外部作用域的一个简单方法是在一个明确的嵌套作用域中运行它。

> 1. 避免使用eval函数创建的变量污染调用者的作用域；
> 2. 如果eval函数代码可能覆盖全局变量，将此调用封装到嵌套的函数中以防止作用域污染。

### 17、间接调用eval函数优于直接调用
eval函数具有访问调用时的整个作用域的能力，eval函数很难高效的调用任何一个函数，一旦被调用的函数是eval函数，那么每个函数都要确保在运行时的整个作用域对eval函数是可访问的，性能损耗高昂。
作为一种折中方案，语言标准逐渐演化出来两种不同调用eval函数的方法：
1. 直接调用eval函数的方式，编译器确保被执行的程序具有完全访问调用者局部作用域的权限；
2. 其他调用eval函数的方式被认为是间接方式，只在全局作用域内对eval函数的参数求值。
	```javascript
    (0, eval)(src);
    ```

> 1. 将eval函数在同一个毫无意义的字面量包裹在序列表达式中以达到强制使用间接调用eval函数的目的；
> 2. 尽可能间接调用eval函数，而不要直接调用eval函数。

## 使用函数
### 18、理解函数调用、方法调用及构造函数调用之间的不同
> 1. 方法调用将调用该方法的对象作为调用接收者（绑定到this变量的对象被称为调用接收者receiver）；
> 2. 函数调用将全局对象（处于严格模式时为undefined）作为其接收者。一般很少使用函数调用语法来调用方法；
> 3. 构造函数需要通过new运算符调用，并产生一个新的对象作为其接收者。

### 19、熟练掌握高阶函数
> 1. 高阶函数是那些将函数作为参数或返回值的函数；
> 2. 熟悉掌握现有库中的高阶函数；
> 3. 学会发现可以被高阶函数所取代的常见的编码模式。

### 20、使用call方法自定义接收者来调用方法
> 1. 使用call方法自定义接收者来调用函数；
> 2. 使用call方法可以调用在给定的对象中不存在的方法；
> 3. 使用call方法定义高阶函数允许使用者给回调函数指定接收者。

### 21、使用apply方法通过不同数量的参数调用函数
> 1. 使用apply方法指定一个可计算的参数数组来调用可变参数的函数；
> 2. 使用apply方法的第一个参数给可变参数的方法提供一个接收者。

### 22、使用arguments创建可变参数的函数
### 23、永远不要修改arguments对象
### 24、使用变量保存arguments的引用
### 25、使用bind方法提取具有确定接收者的方法
### 26、使用bind方法实现函数柯里化
### 27、使用闭包而不是字符串来封装代码
### 28、不要依赖函数对象的toString方法
### 29、避免使用非标准的栈检查属性
## 对象和原型
### 30、理解prototype，getPrototypeOf和__proto__之间的不同
### 31、使用Object.getPrototypeOf函数而不是__proto__属性
### 32、始终不要修改__proto__属性
### 33、使构造函数和new操作符无关
### 34、在原型中存储方法
### 35、使用闭包存储私有属性
### 36、只将实例对象存储在实例对象中
### 37、认识到this变量的隐式绑定问题
### 38、在子类的构造函数中调用父类的构造函数
### 39、不要重用父类的属性名
### 30、避免继承标准类
### 41、将原型视为实现细节
### 42、避免使用轻率的猴子补丁
## 数组和字典
### 43、使用Object的直接实例构造轻量级的字典
### 44、使用null原型以防止原型污染
### 45、使用hasOwnProperty方法以避免原型污染
### 46、使用数组而不要使用字典来存储有序集合
### 47、绝不要在Object.prototype中增加可枚举的属性
### 48、避免在枚举期间修改对象
### 49、数组迭代要优先使用for循环而不是for...in循环
### 50、迭代方法优于循环
### 51、在类数组上复用通用的数组方法
### 52、数组字面量优于数组构造函数
## 库和API设计
### 53、保持一致的约定
### 54、将undefined看作“没有值”
### 55、接收关键字参数的选项对象
### 56、避免不必要的状态
### 57、使用结构类型设计灵活的接口
### 58、区分数组对象和类数组对象
### 59、避免过度的强制转换
### 60、支持方法链
## 并发
### 61、不要堵塞I/O事件队列
### 62、在异步序列中使用嵌套或命名的回调函数
### 63、当心丢弃错误
### 64、对异步循环使用递归
### 65、不要在计算时堵塞事件队列
### 66、使用计数器来执行并行操作
### 67、绝不要同步的调用异步的回调函数
### 68、使用promise模式清洁异步逻辑


