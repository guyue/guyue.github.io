# Effective JavaScript
编写高质量JavaScript代码的68个有效方法

## 让自己习惯JavaScript

### 1、了解你使用的JavaScript版本
>   1. 确定代码中使用的具体JavaScript版本，并统一编码；
>   2. 确保代码中使用的所有JavaScript特性对于应用程序将要运行的所有环境都是支持的；
>   3. 总是使用严格模式，并在支持严格模式检查的环境中测试代码；
>   4. 当心合并严格代码和非严格代码。

### 2、理解JavaScript的浮点数
>   1. JavaScript中的数字都是双精度浮点数，符合IEEE 754标准制定的64位编码数字——即“doubles”，尽管64位的精度已经相当高，但是浮点数所能表示的也只是一组有限的数字，而不能表示所有的实数集。浮点运算只能产生相似的结果，四舍五入到最接近的可表示的实数；
>   2. JavaScript中的整数仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型；
>   3. JavaScript中位运算比较特殊，首先将浮点数隐式的转化为32位整数（32位大端，big-endian），然后使用整数位模式进行运算，最后将结果转换为标准的JavaScript浮点数；
>   4. 当心浮点运算中的精度陷阱。

### 3、当心隐式的强制转换
>   1. 类型错误可能被隐式的强制转换所隐藏；
>   2. 重载的运算符+是进行加法运算还是字符串链接操作取决于其参数类型（左结合律）；
>   3. 对象通过valueOf方法强制转化为数字，通过toString方法强制转化为字符串；
>   4. 具有valueOf方法的对象应该实现toString方法，返回一个valueOf方法产生的数字的字符串表示；
>   5. 测试一个值是否为未定义的值，应该使用typeof操作符或者与undefined进行比较而不能进行真值运算。

### 4、原始类型优于封装对象
>   1. 除了对象之外，JavaScript有5个原始值类型：布尔值、数字、字符串、null和undefined（ECMAScript标准规定null是一个特殊的类型，但 `typeof` 操作符得到的结果为“object”；
>   2. 当做相等比较时，原始类型的封装对象与其原始值行为不一样；
>   3. 获取和设置原始类型值的属性会隐式的创建封装对象。

### 5、避免对混合类型使用==运算符
#### `==`运算符的强制转换规则
| 操作数1类型 | 操作数2类型 | 强制转换 |
|------------|------------|---------|
| null | undefined| 不转换，总是返回true |
| null或undefined | 其他任何非null或undefined的类型 | 不转换，总是返回false |
| string，number或boolean | Date对象 | 将原始类型转换为数字；将Date对象转换为原始类型（优先尝试toString方法，再尝试valueOf方法） |
| string，number或boolean | 非Date对象 | 将原始类型转换为数字；将非Date对象转换为原始类型（优先尝试valueOf方法，再尝试toString方法） |
| string，number或boolean | string，number或boolean | 将原始类型转换为数字 |

>   1. 当参数类型不同时，`==`运算符应用了一套难以理解的隐式强制转换规则；
>   2. 使用`===`运算符，不涉及任何的隐式强制转换就能明白比较运算；
>   3. 当比较不同类型的值时，使用显式的强制转换使程序的行为更清晰。

### 6、了解分号插入插入（automatic semicolon insertion）的局限
#### 分号插入规则
1. 分号仅在`}`标记之前、一个或多个换行之后和程序输入的结尾被插入，只能在一行、一个代码块和一段程序结束的地方省略分号；
2. 分号仅在随后的标记不能解析时插入，分号插入是一种错误矫正机制；
    `(`、`[`、`+`、`-`和`/`五个字符都能作为一个表达式运算符或者一条语句的前缀，这依赖于具体上下文。需要密切关注下一条语句的开始，从而发现你是否能合法的省略分号。
    JavaScript语法限制产生式（restricted production）不允许在两个字符字符之间出现换行，JavaScript会强制插入分号。
    1. `return`关键字；
    2. `throw`语句；
    3. 带有显式标签的`break`或`continue`语句；
    4. 后置自增或自减运算符（自增运算符即可以前置也可以后置，但是后置运算符不能出现在换行之后）。
3. 分号不会作为分隔符在`for`循环空语句的头部被自动插入，空循环体的`while`循环同样也需要显式的分号。

>   1. 仅在`}`标记之前、一行的结束和程序的结束处推导分号；
>   2. 仅在紧接着的标记不能被解析的时候推导分号；
>   3. 在以`(`、`[`、`+`、`-`或`/`字符开头的语句前决不能省略分号；
>   4. 当脚本链接的时候，在脚本之间显示的插入分号；
>   5. 在`return`、`throw`、`break`、`continue`、`++`或`--`的参数之前决不能换行；
>   6. 分号不能作为`for`循环的头部或空语句的分隔符而被推导出来。

### 7、视字符串为16位的代码单元序列
>	1. JavaScript字符串由16位的代码单元组成，而不是由Unicode代码点组成；
>	2. JavaScript使用两个代码单元表示2^16及其以上的Unicode代码点，这两个代码单元被称为代理对；
>	3. 字符串属性和方法（如`length`，`charAt`和`charCodeAt`）和正则表达式（如单字符模式`.`）都是基于代码单元层级，而不是代码点层级。基本多文种平面（Basic Multilingual Plane，BMP）中的字符用一个代码单元表示，辅助平面（supplementary plane）中的字符用两个代码单元表示；
>	4. 使用第三方库编写可识别代码点的字符串操作；
>	5. 每当你使用一个含有字符串操作的库时，你都需要查阅该库文档，确认其处理代码点整个范围的方式。

## 变量作用域
### 8、尽量少用全局对象
>	1. 避免声明全局变量；
>	2. 尽量声明局部变量，变量的作用域控制的越小越好；
>	3. 避免对全局对象添加属性；
>	4. 使用全局对象来做平台特性检测。

### 9、始终声明局部变量
如果存在比全局变量更麻烦的事，那就是意外的全局变量；故意的创建全局变量是不好的风格，而意外的创建全局变量僵尸彻头彻尾的灾难。

>	1. 始终使用var声明新的局部变量；
>	2. 使用lint工具帮忙检查未声明的变量。

### 10、避免使用with
在with代码块的内部，变量查找从搜索给定的对象名的属性开始。如果在这个对象中没有找到该属性，则继续在外部作用域中搜索。在一个正常的作用域中，与局部作用域中的局部变量一一对应的作用域绑定存储在与之对应的环境层级中；但对于with作用域，绑定集合依赖于执行时间点时的对象。
人力不可预测的特性对于优化编译器同样不可预测。通常情况下，JavaScript作用域可被表示为高效的内部数据结构，变量查找会非常快速。但是由于with代码块需要搜索对象的原型链来查找with代码块中的所有变量，其运行速度远低于一般的代码块。

>	1. 避免使用with语句；
>	2. 使用简短的变量名代替重复访问的对象；
>	3. 显式的将对象属性赋值给局部变量，而不是使用with语句隐式的引用它们。
>	```
>	// 不推荐
>   var max = Math.max;
>   with(Math) {
>	    max(x, y);
>	}
>	// 推荐
>   var max = Math.max;
>   max(x, y);
>	```

### 11、熟练使用闭包
#### 闭包的三个基础：
1. JavaScript允许你引用在当前函数以外定义的变量；
2. JavaScript的函数是第一类（first-class）对象，你可以返回一个内部函数，并在稍后调用它。即使外部函数调用已经结束，返回的内部函数仍然可以引用在外部函数中所定义的变量；
    > JavaScript的函数值包含了比调用它们时执行所需要的代码还要多的信息，在函数值内部存储该函数可能会引用的定义在其封闭作用域的变量。在其所涵盖的作用域内跟踪变量的函数被称为闭包。
3. 闭包可以更新外部变量的值，闭包存储的是其外部变量的引用而不是值；

>   1. 函数可以引用定义在其外部作用域的变量；
>   2. 闭包比创建它们的函数有更长的生命周期；
>   3. 闭包在内部存储其引用的外部变量，并能读写这些变量。

### 12、理解变量声明提升
JavaScript支持词法作用域（lexical scoping），但不支持块级作用域。可以把JavaScript中变量声明看成声明和赋值两部分。JavaScript会隐式提升（hoists）声明部分到函数的顶部，而将赋值留在原地。

异常处理是JavaScript中没有块级作用域的反例，try…catch语句将捕获的异常绑定到一个变量，该变量的作用域只有catch语句块。

>   1. 在代码块中变量声明会被隐式的提升到函数的顶部；
>   2. 重复声明的变量被视为同一个变量；
>   3. 考虑手动提升局部变量的声明，从而避免混淆。

### 13、使用立即调用的函数表达式创建局部作用域
>   1. 理解绑定与赋值的区别；
>   2. 闭包通过引用而不是值来捕获他们的外部变量；
>   3. 使用立即调用的函数表达式（IIFE，发音为“iffy”）来创建局部作用域；
>   4. 当心在立即调用的函数表达式中包裹代码块可能改变其行为的情形（比如代码块中不能包含跳出块的break和continue语句）。

### 14、当心命名函数表达式笨拙的作用域
匿名和命名函数表达式（named function expression）的官方区别在于后者会绑定到其函数名相同的变量上，该变量将作为该函数内的一个局部变量。
遗憾的是，命名函数表达式的作用域和兼容性问题严重，主要是两方面的原因，ECMAScript规范的错误和主流JavaScript引擎中的Bug。

规范的错误在ES3中就存在，规范要求将命名函数表达式的作用域表示为一个对象，该作用域对象只包含一个属性，该属性将函数名和函数自身绑定起来。该作用域对象也继承了Object.prototype的属性。这意味着仅仅是给函数表达式命名也会将Object.prototype中的所有属性引入到作用域中。幸运的是ES5修正了这个错误，在Chrome50、Safari9.1和Firefox 45中未复现这个错误。
在系统中避免对象污染函数表达式作用域的最好方式是避免任何时候在Object.prototype中添加属性，以及避免使用任何与标准Object.prototype属性同名的局部变量。

一些JavaScript引擎中存在的另一个缺陷是对命名函数表达式的声明提升到函数定义所在的作用域，个别JavaScript引擎甚至把函数表达式变量和命名匿名表达式这两个函数当做不同的对象，导致重复的内存分配。在Chrome50、Safari9.1和Firefox 45中未复现这个错误。

> 1. 在Error对象和调试器对象中使用命名函数表达式改进栈追踪；
> 2. 在ES3和有问题的JavaScript环境中谨记命名函数表达式的作用域会被Object.prototype污染；
> 3. 谨记在错误百出的JavaScript环境中提升命名函数表达式声明的错误，并导致命名函数表达式的重复污染；
> 4. 考虑避免使用命名函数表达式或在发布前删除函数名；
> 5. 如果你将代码发布到正确实现的ES5环境中，那么你没有什么好担心的。

### 15、当心局部块函数声明笨拙的作用域
JavaScript没有块级作用域，所以块级代码中的内部函数的作用域应该是整个函数。但并不是所有的JavaScript环境都这样，有些环境在运行时根据包含函数的块是否被执行来有条件的绑定内部函数。

> 1. 始终将函数声明置于程序或被包含的函数的最外层以避免不可移植的行为；
> 2. 使用var声明和有条件的赋值语句代替有条件的函数声明。

### 16、避免使用eval创建局部变量
ES5严格模式将eval函数运行在一个嵌套的作用域中以防止作用域污染，保证eval函数不影响外部作用域的一个简单方法是在一个明确的嵌套作用域中运行它。

> 1. 避免使用eval函数创建的变量污染调用者的作用域；
> 2. 如果eval函数代码可能覆盖全局变量，将此调用封装到嵌套的函数中以防止作用域污染。

### 17、间接调用eval函数优于直接调用
eval函数具有访问调用时的整个作用域的能力，eval函数很难高效的调用任何一个函数，一旦被调用的函数是eval函数，那么每个函数都要确保在运行时的整个作用域对eval函数是可访问的，性能损耗高昂。
作为一种折中方案，语言标准逐渐演化出来两种不同调用eval函数的方法：
1. 直接调用eval函数的方式，编译器确保被执行的程序具有完全访问调用者局部作用域的权限；
2. 其他调用eval函数的方式被认为是间接方式，只在全局作用域内对eval函数的参数求值。
	```javascript
    (0, eval)(src);
    ```

> 1. 将eval函数在同一个毫无意义的字面量包裹在序列表达式中以达到强制使用间接调用eval函数的目的；
> 2. 尽可能间接调用eval函数，而不要直接调用eval函数。

## 使用函数
### 18、理解函数调用、方法调用及构造函数调用之间的不同
> 1. 方法调用将调用该方法的对象作为调用接收者（绑定到this变量的对象被称为调用接收者receiver）；
> 2. 函数调用将全局对象（处于严格模式时为undefined）作为其接收者。一般很少使用函数调用语法来调用方法；
> 3. 构造函数需要通过new运算符调用，并产生一个新的对象作为其接收者。

### 19、熟练掌握高阶函数
> 1. 高阶函数是那些将函数作为参数或返回值的函数；
> 2. 熟悉掌握现有库中的高阶函数；
> 3. 学会发现可以被高阶函数所取代的常见的编码模式。

### 20、使用call方法自定义接收者来调用方法
> 1. 使用call方法自定义接收者来调用函数；
> 2. 使用call方法可以调用在给定的对象中不存在的方法；
> 3. 使用call方法定义高阶函数允许使用者给回调函数指定接收者。

### 21、使用apply方法通过不同数量的参数调用函数
> 1. 使用apply方法指定一个可计算的参数数组来调用可变参数的函数；
> 2. 使用apply方法的第一个参数给可变参数的方法提供一个接收者。

### 22、使用arguments创建可变参数的函数
> 1. 使用隐式的arguments对象实现可变参数的函数；
> 2. 考虑对可变参数的函数提供一个额外的固定元数的版本，从而使使用者无需借助apply方法。

### 23、永远不要修改arguments对象
arguments对象并不是函数参数的副本，所有命名参数都是arguments对象中对应索引的别名。在ES5的严格模式下，函数参数不支持对其arguments对象取别名。

> 1. 永远不要修改arguments对象；
> 2. 使用[].slice.call(arguments)将arguments对象复制到一个真正的数组中再进行修改。

### 24、使用变量保存arguments的引用
> 1. 当引用arguments时当心函数嵌套层级；
> 2. 绑定一个明确作用域的引用到arguments变量，从而可以在嵌套的函数中引用它。

### 25、使用bind方法提取具有确定接收者的方法
> 1. 要注意，提取一个方法不会将方法的接收者绑定到该方法的对象上；
> 2. 当给高阶函数传递对象方法时，使用匿名函数在适当的接收者上调用该方法；
> 3. 使用bind方法创建绑定到适当接收者的函数。

### 26、使用bind方法实现函数柯里化
> 1. 使用bind方法实现函数柯里化，即创建一个固定需求参数子集的委托函数；
> 2. 传入null或undefined作为接收者的参数来实现柯里化，从而忽略掉其接收者。

### 27、使用闭包而不是字符串来封装代码
函数是一种将代码做为数据结构存储的便利方式，这些代码可以随后被执行。这使得富有表现力的高阶函数抽象如map和forEach成为可能。它也是JavaScript异步I/O方法的核心。

> 1. 当将字符串传递给eval函数以执行它们的API时，绝不要在字符串中包含局部变量引用和赋值；
> 2. 接受函数调用的API优于使用eval函数执行字符串的API。

### 28、不要依赖函数对象的toString方法
> 1. ECMAScript标准对函数对象的toString方法的返回结果并没有进行任何要求，当调用函数的toString方法时，并没有要求JavaScript引擎能够精确的获取到函数的源代码；
> 2. 由于在不同的引擎下调用toString方法的结果可能不同，所以绝不要信赖函数源代码的详细细节。
> 3. toString方法的执行结果并不会暴露存储在闭包中的局部变量值。
> 4. 通常情况下，应该避免使用函数对象的toString方法。

### 29、避免使用非标准的栈检查属性
在某些旧的宿主环境中，每个arguments对象都含有额外的callee属性，函数对象都包含caller。前者指向使用该arguments对象被调用的函数；后者指向调用该函数的函数。ES5的严格模式下，两者被明令禁止。

> 1. 避免使用非标准的functionName.caller和arguments.callee属性，因为它们不具备良好的移植性；
> 2. 避免使用非标准的函数对象的caller属性，在函数的递归调用中caller属性会自动更新，容易造成歧义。

## 对象和原型
### 30、理解prototype，getPrototypeOf和__proto__之间的不同
> 1. `C.prototype`属性是new C()创建的对象的原型；
> 2. `Object.getPrototypeOf(obj)`是ES5中检索对象原型的标准函数；
> 3. `obj.__proto__`是检索对象原型的非标准方法；
> 4. 类是由一个构造函数和一个关联的原型组成的一种设计模式。

### 31、使用Object.getPrototypeOf函数而不是__proto__属性
> 1. 使用符合标准的`Object.getPrototypeOf`函数而不要使用非标准的`__proto__`属性；
> 2. 在支持`__proto__`属性的非ES5环境中实现`Object.getPrototypeOf`函数。

```javascript
if (Object.getPrototypeOf === undefined) {
    Object.getPrototypeOf = function (obj) {
        var type = typeof obj;
        if (!obj || (type !== 'object' && type !== 'function')) {
            throw new TypeError('not an object');
        }
        return obj.__proto__;
    }
}
```

### 32、始终不要修改__proto__属性
> 1. 始终不要修改对象的`__proto__`属性；
> 2. 使用`Object.create`函数给新对象设置自定义的原型。


### 33、使构造函数和new操作符无关
> 1. 通过使用new操作符或Object.create方法在构造函数定义中调用自身使得该构造函数于调用语法无关；
> 2. 当一个函数期望使用new操作符调用时，清晰的文档化该函数。

```javascript
if (Object.create === undefined) {
    Object.create = function (prototype) {
        function C() {}
        C.prototype = prototype;
        return new C();
    }
}
```


### 34、在原型中存储方法
> 1. 现代的JavaScript引擎深度优化了原型查找，所以将方法复制到实例对象并一定保证速度有明显的提升，但实例方法比原型方法肯定会占用更多的内存。将方法存储在实例对象中将创建多个函数的副本，因为每个实例对象都有一份副本；
> 2. 将方法存储在原型中优于存储在实例对象中。

### 35、使用闭包存储私有属性
闭包是一种简朴的数据结构。它们将数据存储到封闭的变量中而不提供对这些变量的直接访问。获取闭包内部结构的唯一方式是该函数显式的提供获取它的途径。

> 1. 闭包变量是私有的，只能通过局部的引用获取；
> 2. 将局部变量作为私有数据从而通过方法实现信息隐藏。


### 36、只将实例对象存储在实例对象中
> 1. 原型对象与其实例之间存在一对多的关系，共享可变数据可能会出问题，因为其原型是被所有的实例共享的；
> 2. 将可变的实例状态存储在实例对象中。


### 37、认识到this变量的隐式绑定问题
> 1. 每个函数都有一个this变量的隐式绑定，该this变量的绑定值是在调用该函数时确定的。this变量的作用域总是由其最近的封闭函数所确定；
> 2. 使用一个局部变量（通常命名为self、me或that）使得this绑定对于内部函数是可用的。


### 38、在子类的构造函数中调用父类的构造函数
> 1. 在子类构造函数中显示地传入this作为调用父类构造函数的接收者；
> 2. 使用Object.create函数来构造子类的原型对象以避免调用父类的构造函数。

### 39、不要重用父类的属性名
> 1. 留意父类使用的所有属性名；
> 2. 不要在子类中重用父类的属性名。


### 30、避免继承标准类
ECMAScript标准库中的大多数构造函数的某些属性或方法期望具有正确的[[class]]属性或其他特殊的内部属性，然而子类却无法正确提供。基于这个原因，最好避免继承以下的标准类：Array、Boolean、Date、Function、Number、RegExp或String。

> 1. 继承标准类往往会由于一些特殊的内部属性（如[[class]]）而破坏；
> 2. 使用属性委托优于继承标准类。


### 41、将原型视为实现细节
> 1. 对象是接口，原型是实现；
> 2. 避免检查你无法控制的对象的原型结构；
> 3. 避免检查你无法控制的对象的内部属性。


### 42、避免使用轻率的猴子补丁
由于对象共享原型，因此每一个对象都可以增加、删除或修改原型的属性，这种行为统称为猴子补丁（monkey-patching）。

> 1. 避免使用轻率的猴子补丁；
> 2. 记录程序库所执行的所有猴子补丁；
> 3. 考虑通过将修改置于一个导出函数中，使猴子补丁成为可选项；
> 4. 使用猴子补丁为缺失的标准API提供polyfills。


## 数组和字典
### 43、使用Object的直接实例构造轻量级的字典
JavaScript对象的核心是一个字符串属性名称与属性值的映射表。将对象作为轻量级字典的首要原则是：应该仅仅将Object的直接实例作为字典，而不是其子类，当然也不是数组。

> 1. 使用对象字面量构建轻量级字典；
> 2. 轻量级字典应该是Object.prototype的直接子类，以使for...in循环避免原型污染。


### 44、使用null原型以防止原型污染
> 1. 在ES5环境中，使用`Object.create(null)`创建的空对象是不太容易被污染的；
> 2. 在一些较老的支持`__proto__`的环境中，考虑使用`{__proto__: null}`；
> 3. 但要注意`__proto__`既不标准，也不是完全可移植的，并且可能会在未来的JavaScript环境中去除；
> 4. 绝不要使用`__proto__`名作为字典中的key，因为一些环境将其作为特殊的属性对待。


### 45、使用hasOwnProperty方法以避免原型污染
> 1. 使用`hasOwnProperty`方法避免受原型污染；
> 2. 使用call方法避免`hasOwnProperty`方法被覆盖；
> 3. 考虑实现字典类，封装`hasOwnProperty`测试代码；
> 4. 使用字典类避免将`__proto__`作为key来使用。

```javascript
function Dict(elements) {
    this.elements = elements || {};
    this.hasSpecialProto = false;
    this.specialProto = undefined;
}

Dict.prototype.has = function (key) {
    if (key === '__proto__') {
        return this.hasSpecialProto;
    }
    return ({}).hasOwnProperty.call(this.elements, key);
};

Dict.prototype.get = function (key) {
    if (key === '__proto__') {
        return this.specialProto;
    }
    return this.has(key) ? this.elements[key] : undefined;
};

Dict.prototype.set = function (key, value) {
    if (key === '__proto__') {
        this.hasSpecialProto = true;
        this.specialProto = value;
    } else {
        this.elements[key] = value;
    }
};

Dict.prototype.remove = function (key) {
    if (key === '__proto__') {
        this.hasSpecialProto = false;
        this.specialProto = undefined;
    } else {
        delete this.elements[key];
    }
};
```


### 46、使用数组而不要使用字典来存储有序集合
一个JavaScript对象是一个无序的属性集合。获取和设置不同的属性与顺序无关，都会以大致相同的效率产生相同的结果。ECMAScript标准并未规定属性存储的任何特定顺序，甚至对于枚举对象也未涉及。

例如：浮点型算术运算的四舍五入会导致对计算顺序的微妙依赖。
```javascript
(0.8 + 0.7 + 0.6 + 0.9) / 4;
(0.6 + 0.8 + 0.7 + 0.9) / 4;
```

> 1. 使用for...in循环来枚举对象属性应当与顺序无关；
> 2. 如果聚集运算字典中的数据，确保聚集操作与顺序无关；
> 3. 是用数组而不是字典来存储有序集合。


### 47、绝不要在Object.prototype中增加可枚举的属性
> 1. 避免在Object.prototype中增加属性；
> 2. 考虑编写一个函数代替Object.prototype方法；
> 3. 如果你确实需要在Object.prototype中增加属性，请使用ES5中的Object.defineProperty方法将他们定义为不可枚举的属性。


### 48、避免在枚举期间修改对象
ECMAScript标准中规定：
如果被枚举的对象在枚举期间添加了新的属性，那么在枚举期间并不能保证新添加的属性能够被访问。

> 1. 当使用for...in循环枚举一个对象的属性时，确保不要修改该对象；
> 2. 当迭代一个对象时，如果该对象的内容可能会在循环期间被改变，应该使用while循环或经典的for循环来代替for...in循环；
> 3. 为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典对象。


### 49、数组迭代要优先使用for循环而不是for...in循环
> 1. 迭代数组的索引属性应当总是使用for循环而不是for...in循环，即使是数组的索引属性，对象属性key始终是字符串；
> 2. 考虑在循环之前将数组的长度存储在一个局部变量中以避免重新计算数组长度；


### 50、迭代方法优于循环
> 1. 使用迭代方法（如Array.prototype.forEach和Array.prototype.map）替换for循环使得代码更可读，并且避免了重复循环控制逻辑；
> 2. 使用自定义的迭代函数来抽象未被标准库支持的常见循环模式；
> 3. 在需要提前终止循环的情况下，仍然推荐使用传统的循环。另外，some和every方法也可用于提前退出。


### 51、在类数组上复用通用的数组方法
Array.prototype中的标准方法被设计成“类数组”对象可复用的方法，即使这些对象并没有继承Array。
数组对象的基本契约有两个基本规则：
1. 具有一个范围在0到2^32 - 1的整型length属性；
2. length属性大于该对象的最大索引。索引是一个范围在0到2^32 - 2的整数，它的字符串表示的是该对象中的一个key。

符合这两个规则的对象即可以看做“类数组”对象，例如arguments对象、NodeList类、字符串等。

模拟JavaScript数组的所有行为很精妙，这主要归功于数组行为的两个方面：
1. 将length属性值设为小于n的值会自动的删除索引值大于或等于n的所有属性；
2. 增加一个索引值为n（大于或等于length属性值）的属性会自动的设置length属性为n + 1；

> 1. 对于类数组对象，通过提取方法对象并使用其call方法来复用通用的Array方法；
> 2. 任意一个具有索引属性和恰当length属性的对象都可以使用通用的Array方法。

### 52、数组字面量优于数组构造函数
> 1. 如果数组构造函数的只有一个实参且参数值是数字，则数组构造函数的行为和其他实参情况的行为是不同的；
> 2. 使用数组字面量代替数组构造函数。


## 库和API设计
### 53、保持一致的约定
> 1. 在变量命名和函数签名中使用一致的约定；
> 2. 不要偏离用户在他们的开发平台中很可能遇到的约定。


### 54、将undefined看作“没有值”
> 1. 避免使用undefined表示任何非特定值；
> 2. 使用描述性的字符串值或命名布尔属性的对象，而不要使用undefined或null来表示特定应用标志；
> 3. 提供参数默认值应当采用测试具名参数undefined的方式，而不是检查arguments.length；
> 4. 在允许0、NaN或空字符串为有效参数的地方，决不要通过真值测试来实现参数默认值。


### 55、接收关键字参数的选项对象
> 1. 使用选项对象使得API更具可读性、更容易记忆；
> 2. 所有通过选项对象提供的参数应当被视为可选的；
> 3. 使用extend函数抽象出从选项对象中提取值的逻辑。


### 56、避免不必要的状态
> 1. 尽可能使用无状态的API；
> 2. 如果API是有状态的，标示出每个操作与哪些状态有关联。


### 57、使用结构类型设计灵活的接口
> 1. 使用结构类型（也成为鸭子类型）来设计灵活的对象接口；
> 2. 结构接口更灵活、更轻量，所以应该避免使用继承；
> 3. 针对单元测试，使用mock对象即接口的替代实现来提供可复验的行为。


### 58、区分数组对象和类数组对象
> 1. 重载两种类型意味着必须有一种方法来区别这两种情况。不可能检测一个值是否实现了一种结构性的接口。API绝不应该重载与其他类型有重叠的类型；
> 2. 当重载一个结构类型与其他类型时，先测试其他类型；
> 3. 当重载其他对象类型时，接收真数组而不是类数组对象；
> 4. 文档标注你的API是否接收真数组或类数组值；
> 5. 使用ES5提供的Array.isArray方法测试真数组。


### 59、避免过度的强制转换
> 1. 避免强制转换和重载的混用；
> 2. 考虑防御性的监视非预期的输入。


### 60、支持方法链
> 1. 使用方法链来连接无状态的操作；
> 2. 通过在无状态的方法中返回新对象来支持方法链；
> 3. 通过在有状态的方法中返回this来支持方法链。


## 并发
### 61、不要堵塞I/O事件队列
### 62、在异步序列中使用嵌套或命名的回调函数
### 63、当心丢弃错误
### 64、对异步循环使用递归
### 65、不要在计算时堵塞事件队列
### 66、使用计数器来执行并行操作
### 67、绝不要同步的调用异步的回调函数
### 68、使用promise模式清洁异步逻辑


