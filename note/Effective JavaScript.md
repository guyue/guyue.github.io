# Effective JavaScript
编写高质量JavaScript代码的68个有效方法

## 让自己习惯JavaScript

### 1、了解你使用的JavaScript版本
>   1. 确定代码中使用的具体JavaScript版本，并统一编码；
>   2. 确保代码中使用的所有JavaScript特性对于应用程序将要运行的所有环境都是支持的；
>   3. 总是使用严格模式，并在支持严格模式检查的环境中测试代码；
>   4. 当心合并严格代码和非严格代码。

### 2、理解JavaScript的浮点数
>   1. JavaScript中的数字都是双精度浮点数，符合IEEE 754标准制定的64位编码数字——即“doubles”，尽管64位的精度已经相当高，但是浮点数所能表示的也只是一组有限的数字，而不能表示所有的实数集。浮点运算只能产生相似的结果，四舍五入到最接近的可表示的实数；
>   2. JavaScript中的整数仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型；
>   3. JavaScript中位运算比较特殊，首先将浮点数隐式的转化为32位整数（32位大端，big-endian），然后使用整数位模式进行运算，最后将结果转换为标准的JavaScript浮点数；
>   4. 当心浮点运算中的精度陷阱。

### 3、当心隐式的强制转换
>   1. 类型错误可能被隐式的强制转换所隐藏；
>   2. 重载的运算符+是进行加法运算还是字符串链接操作取决于其参数类型（左结合律）；
>   3. 对象通过valueOf方法强制转化为数字，通过toString方法强制转化为字符串；
>   4. 具有valueOf方法的对象应该实现toString方法，返回一个valueOf方法产生的数字的字符串表示；
>   5. 测试一个值是否为未定义的值，应该使用typeof操作符或者与undefined进行比较而不能进行真值运算。

### 4、原始类型优于封装对象
>   1. 除了对象之外，JavaScript有5个原始值类型：布尔值、数字、字符串、null和undefined（ECMAScript标准规定null是一个特殊的类型，但 `typeof` 操作符得到的结果为“object”；
>   2. 当做相等比较时，原始类型的封装对象与其原始值行为不一样；
>   3. 获取和设置原始类型值的属性会隐式的创建封装对象。

### 5、避免对混合类型使用==运算符
#### `==`运算符的强制转换规则
| 操作数1类型 | 操作数2类型 | 强制转换 |
|------------|------------|---------|
| null | undefined| 不转换，总是返回true |
| null或undefined | 其他任何非null或undefined的类型 | 不转换，总是返回false |
| string，number或boolean | Date对象 | 将原始类型转换为数字；将Date对象转换为原始类型（优先尝试toString方法，再尝试valueOf方法） |
| string，number或boolean | 非Date对象 | 将原始类型转换为数字；将非Date对象转换为原始类型（优先尝试valueOf方法，再尝试toString方法） |
| string，number或boolean | string，number或boolean | 将原始类型转换为数字 |

>   1. 当参数类型不同时，`==`运算符应用了一套难以理解的隐式强制转换规则；
>   2. 使用`===`运算符，不涉及任何的隐式强制转换就能明白比较运算；
>   3. 当比较不同类型的值时，使用显式的强制转换使程序的行为更清晰。

### 6、了解分号插入插入（automatic semicolon insertion）的局限
#### 分号插入规则
1. 分号仅在`}`标记之前、一个或多个换行之后和程序输入的结尾被插入，只能在一行、一个代码块和一段程序结束的地方省略分号；
2. 分号仅在随后的标记不能解析时插入，分号插入是一种错误矫正机制；
    `(`、`[`、`+`、`-`和`/`五个字符都能作为一个表达式运算符或者一条语句的前缀，这依赖于具体上下文。需要密切关注下一条语句的开始，从而发现你是否能合法的省略分号。
    JavaScript语法限制产生式（restricted production）不允许在两个字符字符之间出现换行，JavaScript会强制插入分号。
    1. `return`关键字；
    2. `throw`语句；
    3. 带有显式标签的`break`或`continue`语句；
    4. 后置自增或自减运算符（自增运算符即可以前置也可以后置，但是后置运算符不能出现在换行之后）。
3. 分号不会作为分隔符在`for`循环空语句的头部被自动插入，空循环体的`while`循环同样也需要显式的分号。

>   1. 仅在`}`标记之前、一行的结束和程序的结束处推导分号；
>   2. 仅在紧接着的标记不能被解析的时候推导分号；
>   3. 在以`(`、`[`、`+`、`-`或`/`字符开头的语句前决不能省略分号；
>   4. 当脚本链接的时候，在脚本之间显示的插入分号；
>   5. 在`return`、`throw`、`break`、`continue`、`++`或`--`的参数之前决不能换行；
>   6. 分号不能作为`for`循环的头部或空语句的分隔符而被推导出来。

### 7、视字符串为16位的代码单元序列

## 变量作用域额
### 8、尽量少用全局对象
### 9、始终声明局部变量
### 10、避免使用with
### 11、熟练使用闭包
### 12、理解变量声明提升
### 13、使用立即调用的函数表达式创建局部作用域
### 14、当心命名函数表达式笨拙的作用域
### 15、当心局部块函数声明笨拙的作用域
### 16、避免使用eval创建局部变量
### 17、间接调用eval函数优于直接调用
## 使用函数
### 18、理解函数调用、方法调用及构造函数调用之间的不同
### 19、熟练掌握高阶函数
### 20、使用call方法自定义接收者来调用方法
### 21、使用apply方法通过不同数量的参数调用函数
### 22、使用arguments创建可变参数的函数
### 23、永远不要修改arguments对象
### 24、使用变量保存arguments的引用
### 25、使用bind方法提取具有确定接收者的方法
### 26、使用bind方法实现函数柯里化
### 27、使用闭包而不是字符串来封装代码
### 28、不要依赖函数对象的toString方法
### 29、避免使用非标准的栈检查属性
## 对象和原型
### 30、理解prototype，getPrototypeOf和__proto__之间的不同
### 31、使用Object.getPrototypeOf函数而不是__proto__属性
### 32、始终不要修改__proto__属性
### 33、使构造函数和new操作符无关
### 34、在原型中存储方法
### 35、使用闭包存储私有属性
### 36、只将实例对象存储在实例对象中
### 37、认识到this变量的隐式绑定问题
### 38、在子类的构造函数中调用父类的构造函数
### 39、不要重用父类的属性名
### 30、避免继承标准类
### 41、将原型视为实现细节
### 42、避免使用轻率的猴子补丁
## 数组和字典
### 43、使用Object的直接实例构造轻量级的字典
### 44、使用null原型以防止原型污染
### 45、使用hasOwnProperty方法以避免原型污染
### 46、使用数组而不要使用字典来存储有序集合
### 47、绝不要在Object.prototype中增加可枚举的属性
### 48、避免在枚举期间修改对象
### 49、数组迭代要优先使用for循环而不是for...in循环
### 50、迭代方法优于循环
### 51、在类数组上复用通用的数组方法
### 52、数组字面量优于数组构造函数
## 库和API设计
### 53、保持一致的约定
### 54、将undefined看作“没有值”
### 55、接收关键字参数的选项对象
### 56、避免不必要的状态
### 57、使用结构类型设计灵活的接口
### 58、区分数组对象和类数组对象
### 59、避免过度的强制转换
### 60、支持方法链
## 并发
### 61、不要堵塞I/O事件队列
### 62、在异步序列中使用嵌套或命名的回调函数
### 63、当心丢弃错误
### 64、对异步循环使用递归
### 65、不要在计算时堵塞事件队列
### 66、使用计数器来执行并行操作
### 67、绝不要同步的调用异步的回调函数
### 68、使用promise模式清洁异步逻辑
