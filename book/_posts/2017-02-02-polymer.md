---
layout: post
title: Polymer——面向未来的Web组件开发
tags: 读书笔记
---

### 第一章 概述

Web组件技术将用户界面和逻辑封装在一起，以一种可重用的方式开发用户界面。

Web组件正在逐渐被主流接收，[Polymer](https://www.polymer-project.org/)小组走在了最前列，[Mozilla](http://x-tags.org/)也有自己的框架（[Mozilla or Microsoft释疑](http://stackoverflow.com/questions/33929771/microsofts-x-tag-vs-mozillas-x-tags)），社区的开发者们也在开发自己的实现方式。


#### 什么是Web组件

> Web组件是用来描述“一组允许开发者高效地表达已存在HTML元素实现”的技术集合的术语。  
> Web组件并不能解决所有问题，但给了开发者一种标准的方式，以将标签的实现打包封装。

Web组件关键概念列表

1. HTML模板

    > HTML模板是随时可以拿出来重复使用、序列化的文档对象模型（DOM）。可在`<template>`标签中编写模板片段（template之前的方式是：DOM节点对象创建、模板引擎、模板函数等）。

2. HTML引用

    > HTML引用用来在应用中接入被加载进来的独立代码片段，开发者只需要通过一个简单的`@include`就可以引用一个小型应用及其所有资源，而不用手动将其下载后再引用。

3. 自定义元素

    > 自定义元素，是在各框架、各平台和领域之间的一种通用、标准的元素生成方式。

4. Shadow DOM

    > Shadow DOM将Web组件中的DOM、样式和数据保护并封装起来，外界不能通过常规手段去改变。


#### 为什么使用Web组件

Web已经逐渐进化为了应用平台，HTML5以及一些新API的出现是Web正在进化为一个应用平台的证据。

> 严格地说，HTML5是一个简单的具有一些新元素的文档模型。然而，当人们谈及HTML5时，更多的是表示包含了新元素、CSS3和一些新的JavaScript API的集合。这些技术重新定义了Web开发。

Web组件通过定义一组新特性，以支持原生的扩展、抽象、引用和封装，允许开发者创建具有标准生命周期的可重用元素（构建网页的部件），并能被任意其他应用所引用。这项标准将为元素和应用之间建立清晰的关系，使创建和维护界面的过程更加平滑。


## 第一部分 UI核心概念

> 软件开发的“基础”是指对设计概念和实现模式的深刻理解。  
> 没有“基础”，开发出的软件不可避免的会漏洞百出。比如，由于对UI组件的布局、拖动、缩放等核心概念的误解而写出失败的代码，因为低效的设计或对标准设计模式理解有误而写出糟糕的API和实现等等。


### 第2章 基础知识

> 编写Voltron组件基类的目的是，提供一套用于构建DOM库的标准，这种标准无关具体实现——比如JavaScript控件、纯Web组件、Polymer组件，等等。

#### DOM抽象层的重要性

直接使用DOM的API很繁琐，尤其当需要兼容多浏览器的时候。jQuery是最著名和最被广泛使用的DOM库，实现了一个完善的DOM库的通用功能，DOM选择器、DOM元素遍历和DOM元素操作等。

#### 控件的API和生命周期

控件应该保持一致的API和通用的生命周期，遵循统一的模式，保持同样的行为，以便于开发、维护和使用。控件的生命周期包括但不限于以下几个阶段：初始化、渲染、事件绑定、销毁等。

完善的API函数需要预设恰当的默认参数，并通过事件允许开发者切入控件的某些阶段实现需求。

#### 继承模式

JavaScript使用原型继承，即直接继承自另一个对象；在类继承体系中，对象是通过类创建的，继承自类。

#### 依赖

当创建一个Web组件时，应该尽最大的努力来限制控件对其他模块的依赖。在添加一项依赖之前，应当充分评估，其所带来的价值是否超过了它的体积和维护成本，这些负担将由控件的使用者来承担。

#### 优化

> 过早优化是万恶之源
> —— Donald Knuth 

当应用的规模足够大时，理解整个应用的生命周期是不可能的。由此更突出控件一致的API和通用的生命周期的重要性。

UI控件基类Voltron主要包括渲染、事件绑定/解绑定、销毁等阶段，并实现一套通用的接口便于扩展和适配这些概念。大部分软件的UI层都包括构建、继承、初始化等概念。控件提供了对应阶段的事件，以便于在实现API细节的过程中，定期的运行性能测试。

在编写代码时要遵循某些最佳实践，比如批量更新DOM，在实现API的过程中进行性能测试，当性能问题显现后再进一步优化。如果你的设计足够合理，那么在软件开发后期性能瓶颈显现之时，你可以单独的优化每一个模块。

#### Web组件不仅仅是JavaScript

Web组件希望解决的是更大的问题——将HTML、CSS、JavaScript封装成一个可扩展的不影响周围DOM节点的集合。通过这种封装、声明性的实现，将Web从一个准开发平台升级为一个真正的开发平台。

#### 示例控件

##### Voltron控件基类
[voltron.js](https://github.com/WebComponentsBook/chapter-2_dialog/blob/master/components/chapter-2_voltron/voltron.js)

##### 对话框类
[dialog.js](https://github.com/WebComponentsBook/chapter-2_dialog/blob/master/dialog.js)

##### 对话框的CSS和HTML
[index.html](https://github.com/WebComponentsBook/chapter-2_dialog/blob/master/index.html)

#### 总结

定义一个具有通用生命周期的控件基类，使应用开发更易于开发、维护、调试，规定插件预期的输出和行为。

### 第3章 文档流和定位

> 每一个Web组件都需要被加入到DOM中，并最终渲染在屏幕上的某个位置与用户交互。DOM元素是Web组件的基石，理解DOM元素如何定位是Web组件开发的关键。  
> 理解浏览器如何布局一个页面，首先需要理解两个关键概念：文档流和定位。

#### 文档流

#### 定位元素

##### offsetParent

##### 定位

#### 计算元素的位置

##### 相对于视窗

##### 相对于文档

#### 定位对话框控件

#### 总结

### 第4章 理解和操作z-index

#### z-index究竟是什么？

#### 渲染层、堆叠次序与z-index

##### 默认堆叠次序

##### 重写默认堆叠次序

#### 堆叠上下文

##### 堆叠上下文是怎么创建的？

##### 事情越来越复杂了

#### 管理z-index

##### z-index管理者对象

#### 转化为jQuery插件

#### 向对话框控件类添加z-index管理功能

#### 总结

## 第二部分 构建UI

### 第5章 克隆节点

#### cloneNode方法

#### 使用jQuery.clone

#### 对话框控件

#### 总结

### 第6章 创建浮层

#### 定义API

#### 工具

##### 检测滚动栏的宽度

##### 计算容器宽度时考虑滚动条

##### 获取元素尺寸和坐标

##### 监听尺寸改变事件和滚动事件

#### 更新选项

#### 销毁

#### 定位

##### 相对视窗或相对另一个元素定位

##### 相对另一个元素定位元素

#### 向对话框控件添加浮层功能

#### 总结

### 第7章 拖动元素

#### 鼠标事件

##### $.mousemove

##### $.mousedown

##### $.mouseup

#### 鼠标事件的最佳实践

##### 1. 在$.mousedown事件中绑定$.mousemove事件

##### 2. 在$.mouseup事件中解除$.mousemove的绑定

##### 3. 将$.mouseup事件响应函数绑定到<body>上

##### 4. 命名所有事件

#### 定义API

#### 创建拖拽柄

#### 拖动起来

##### $.mousedown响应函数

##### $.mousemove响应函数

##### $.mouseup事件响应函数

#### 销毁可拖拽实例

#### 使对话框控件可拖拽

#### 总结

### 第8章 调整元素尺寸

#### 鼠标事件和最佳实践

##### 事件

##### 最佳实践

#### 调整元素尺寸

#### 编写调整尺寸的API

#### 拖拽/尺寸调整柄区

#### 绑定鼠标事件

##### $.mousedown事件响应函数

##### $.mousemove事件响应函数

##### $.mouseup事件响应函数

#### 销毁工作

#### 完成调整尺寸功能

#### 使对话框控件可调整大小

#### 总结

### 第9章 完成对话框控件

#### 添加样式

##### 添加CSS

#### 合并JavaScript文件

#### 总结

## 第三部分 构建HTML5 Web组件

### 第10章 模板

#### 理解模板的重要性

##### 延迟加载资源

##### 延迟渲染内容

##### 从DOM中隐藏内容

#### 创建和使用模板

##### 检测浏览器支持

##### 将模板放到标签中

##### 将模板内容插入到DOM中

#### 使用模板编写对话框组件

##### 创建和包装对话框模板API

##### 实例化对话框组件

#### 抽象对话框模板包装

#### 总结

### 第11章 Shadow DOM

#### 什么是Shadow DOM？

#### Shadow DOM基础概念

##### Shadow宿主

##### Shadow根元素

#### 在Shadow DOM中使用模板

#### Shadow DOM的样式

##### 样式封装

##### 为宿主元素添加样式

##### 在文档中设置Shadow子树根节点样式

#### 内容映射

##### 通过content标签映射

##### 通过选择器映射内容

##### 节点分发和接入点

#### Shadow接入点

#### 事件与Shadow DOM

#### 使用Shadow DOM更新对话框模板

##### 对话框标签

##### 对话框的API

##### 更新对话框的show方法

##### 初始化对话框实例

#### 总结

### 第12章 自定义元素

#### 自定义元素简介

#### 注册自定义元素

#### 扩展元素

##### 扩展自定义元素

##### 扩展自原生元素

#### 定义属性和方法

#### 解析自定义元素

#### 参与自定义元素的生命周期

##### createdCallback

##### attachedCallback

##### detachedCallback

##### attributeChangedCallback

#### 为自定义元素添加样式

#### 在自定义元素中使用模板和Shadow DOM

#### 将对话框组件实现为一个自定义元素

##### 创建对话框自定义元素

##### 实现对话框自定义元素的回调函数

##### 实现对话框自定义元素的API

##### 显示对话框

#### 总结

### 第13章 引入文档

#### 声明引入

#### 获取引入的内容

##### 获取文档

##### 应用样式

##### 获取模板

##### 执行JavaScript

#### 理解引入和主文档的关系

##### 解析引入

##### 跨域

##### 二级引入

#### 加载自定义元素

#### 引入对话框

#### 总结

## 第四部分 使用Polymer测试、构建、部署Web组件

### 第14章 Polymer简介

#### Polymer元素

##### 添加样式

##### 外部资源

##### 过滤表达式

#### 模板格式

##### 数据绑定

##### 循环快

##### 上下文绑定

##### 分支判断

##### 复合模板指令

#### 特性（attribute）和属性（property）：元素的API

##### 原生特性

##### 公开属性

##### 实例方法

#### Polymer的JavaScript API

##### 生命周期方法

##### 事件

##### 处理延迟工作

#### 总结

### 第15章 将对话框迁移至Polymer

#### 到底为什么要迁移到Polymer

#### ”一键迁移“

##### 管理依赖

##### 使用Bower安装依赖

##### 让我们开始吧

#### 太简单了吧

#### Polymer世界中的jQuery

##### 带来了什么

##### 移除jQuery

##### 关于jQuery的结论

#### 总结

### 第16章 测试Web组件

#### PhantomJS 1

#### PhantomJS 2

#### Selenium WebDriver

#### Karma

#### 测试用例

#### 运行测试

#### 总结

### 第17章 打包和发布

#### Vulcanize

#### Gulp

#### Grunt

##### Gruntfiles

##### Grunt任务

##### 注册任务

##### Grunt配置

#### 使用Bower发布组件

##### 注册组件

#### 总结

### 第18章 结语

#### 往何处去

##### Polymer

##### Mozilla X-Tag

##### document-register-element

##### WebComponents.org

##### CustomElements.io

#### 祝你好运
